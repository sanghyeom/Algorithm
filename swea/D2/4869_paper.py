#  종이 붙이기

# 구하고자 하는 문제: 바닥의 크기가 N*20인 바닥을 
# 종이로 붙일 수 있는 서로 다른 경우의 수

# f(N) : 본래 구하고자 하는 문제, 큰 문제
# 작은 문제: f(N-10), f(N-20), ..., f(30), f(20), f(10)

# f(10) = 1
# f(20) = 3
# f(30) = 5

# 작은 문제의 해를 조합해서 => 큰 문제의 해 찾기
# 규칙성을 찾을 때는 무작위로 찾기 보다는 어떤 기준을 정해두고 찾는게 좋음
# ex) 오른쪽으로만 이어서 붙여보자.

# f(30) = f(20) + f(10)*2
# f(40) = f(30) + f(20)*2
# ...
# f(N) = f(N-10) + f(N-20)*2


# DP의 종류: 2가지
# - memoization: 재귀함수 호출 + 재귀함수의 값 기억해두기(똑같은 재귀함수가 호출될 경우 다시 계산 x, 기억한 값을 가져다 씀)
# - tabulation: 반복문으로 풀기, dp table(배열, 리스트)를 먼저 생성, 작은 문제의 해를 구한 후 반복문을 돌면서 보다 큰 문제의 해 반복적으로 만들어냄. 


T = int(input())

for tc in range(1,T+1):

    N =int(input())
    # 문제의 조건에서 N 10 이상 300 이하 . 
    # f(10) ~ f(300) : 값을 기억해둘 리스트를 만들자 !
    dp = [0]*301

    dp[10] = 1
    dp[20] = 3
    dp[30] =  5
    for i in range(40, N+1):
        dp[i] = dp[i-10] + dp[i-20]*2

    print(f'#{tc} {dp[N]}')


